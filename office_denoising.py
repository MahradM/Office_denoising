# -*- coding: utf-8 -*-
"""Office_denoising.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RNSspPY-fcOcqtLrvdzit1oWAMUBixKk

Colab Link: https://colab.research.google.com/drive/1RNSspPY-fcOcqtLrvdzit1oWAMUBixKk?usp=sharing
"""

#@title Libraries
import matplotlib.pyplot as plt
import numpy as np
import cv2
import math
import numpy as np
import scipy.signal
import imageio
from scipy.ndimage import convolve

#@title Downloading Data(Colab)
! gdown 1VJy1osU1kCiMNMkwyOsH-Hyvd1A0ONmY
! gdown 1fEeiQo1c_7tCNL3lvCY3S_Nifm0f7Lqh

noisy_image = cv2.imread("/content/office_noisy.png", cv2.IMREAD_GRAYSCALE)
original_image = cv2.imread("/content/office.png", cv2.IMREAD_GRAYSCALE)

plt.figure(figsize=(10, 8))
plt.subplot(121), plt.imshow(original_image, 'gray'), plt.title('Original Image')
plt.subplot(122), plt.imshow(noisy_image, 'gray'), plt.title('Noisy Image')

plt.show()

"""# 2.Gaussian smoothing"""

def gaussian_kernel(size, sigma):
  kernel = np.zeros((size, size), dtype=np.float64)
  center = (size - 1) / 2

  for x in range(size):
    for y in range(size):
      diff_x = (x - center)**2
      diff_y = (y - center)**2
      kernel[x, y] = (1 / (2 * np.pi * sigma**2)) * np.exp(-(diff_x + diff_y) / (2 * sigma**2))

  return kernel / np.sum(kernel)

def gaussian_smoothing(image, size=5, sigma=1.0):
  # Create the kernel
  kernel = gaussian_kernel(size, sigma)
  #print(kernel)
  smoothed_image = convolve(image, kernel)

  return smoothed_image

#Smoothing using diffrent Sigma
plt.figure(figsize=(15,10))
sigma_list = [0.5, 1, 2, 5, 10, 50]
i=1
for sigma in sigma_list:
  img = gaussian_smoothing(noisy_image, 5, sigma)
  mse = np.mean((img - original_image)** 2)
  plt.subplot(2,3,i), plt.imshow(img, 'gray'), plt.title(f'σ = {sigma}, MSE = {mse}')
  i+=1

#plt.savefig('Diffrent_sigma_Gs.png')
plt.show()

#Calclute image for sigma=(1,50)
mse_values = []
sigma_values = range(1, 51)
for i in sigma_values:
  img = gaussian_smoothing(noisy_image, 5, i)
  mse = np.mean((img - original_image)** 2)
  mse_values.append(mse)
#Choose optimum sigma
min_index = np.argmin(mse_values)
min_sigma = sigma_values[min_index]
min_mse = mse_values[min_index]

plt.plot(list(range(1, 51)), mse_values, marker='o')
plt.title('MSE vs. Gaussian Kernel Sigma')
plt.xlabel('Sigma')
plt.ylabel('Mean Squared Error (MSE)')
plt.grid(True)
#plt.savefig('Diffrent_sigma_Gs_plot.png')
plt.show()
print(f"Optimum σ = {min_sigma}")

"""# 3.Isotropic linear diffusion smoothing"""

def linear_diffusion(image, max_time, d, dt=0.125):
  u = image.astype(np.float64)
  for _ in range(max_time):
    # Compute the Laplacian (du^2/dx + du^2/dy)
    lap = cv2.Laplacian(u, cv2.CV_64F)
    u += dt * d * lap
  u = u.astype(np.uint8)
  return u

#@title Question 1
#Smoothing with diffrent max_time
times = [1, 5, 10, 30, 100]
d = 1
i=1
plt.figure(figsize=(15,10))
for t in times:
  img = linear_diffusion(noisy_image, t, d)
  mse = np.mean((img - original_image)** 2)
  plt.subplot(2,3,i), plt.imshow(img, 'gray'), plt.title(f't = {t}, MSE = {mse}')
  i+=1

plt.subplot(2,3,6), plt.imshow(original_image, 'gray'), plt.title('Original image')
#plt.savefig('Diffrent_time_ldf.png')
plt.show()

#@title Question 2
#Smoothing using diffrent d
diffusivity = [1, 5, 10]
i=1
plt.figure(figsize=(15,10))
for d in diffusivity:
  img = linear_diffusion(noisy_image, 10, d)
  mse = np.mean((img - original_image)** 2)
  plt.subplot(2,2,i), plt.imshow(img, 'gray'), plt.title(f'd = {d}, MSE = {mse}')
  i+=1

plt.subplot(2,2,4), plt.imshow(original_image, 'gray'), plt.title('Original image')
#plt.savefig('Diffrent_d_ldf.png')
plt.show()

#@title Normalized d
#Smoothing using diffrent d
diffusivity = [1, 5, 10]
i=1
plt.figure(figsize=(15,10))
for d in diffusivity:
  img = linear_diffusion(noisy_image, 10, d/10)
  mse = np.mean((img - original_image)** 2)
  plt.subplot(2,2,i), plt.imshow(img, 'gray'), plt.title(f'd = {d}, MSE = {mse}')
  i+=1

plt.subplot(2,2,4), plt.imshow(original_image, 'gray'), plt.title('Original image')
#plt.savefig('Diffrent_d_ldf.png')
plt.show()

#@title Question 3
#Compare Gaussian and Linear diffusion smoothing
times = [1, 5, 10]
d = 1
plt.figure(figsize=(15,10))
i=1
for t in times:
  sigma = np.sqrt(2 * t)
  gaussian_img = gaussian_smoothing(noisy_image, 5, sigma)
  diffusion_img = linear_diffusion(noisy_image, max_time=t, d=d)
  mse_g = np.mean((gaussian_img - original_image)** 2)
  mse_ld = np.mean((diffusion_img - original_image)** 2)
  plt.subplot(3,2,i), plt.imshow(gaussian_img, 'gray'), plt.title(f't = {t}, MSE = {mse_g}, Function = Gaussian')
  i+=1
  plt.subplot(3,2,i), plt.imshow(diffusion_img, 'gray'), plt.title(f't = {t}, MSE = {mse_ld}, Function = Linear diffusion')
  i+=1

#plt.savefig('compare_gs_ld.png')
plt.show()

"""# 4.Isotropic non-linear diffusion smoothing"""

def nonlinearDiffusionFilter(image, max_t, lambda_, dt=0.25):
  x0 = image.astype(np.float64)
  t=0
  while t < max_t:
    gradxX = cv2.Sobel(x0, cv2.CV_64F, 1, 0, ksize=3)
    gradyX = cv2.Sobel(x0, cv2.CV_64F, 0, 1, ksize=3)

    # Compute D
    D = np.zeros_like(x0, dtype=np.float64)
    for i in range(x0.shape[0]):
        for j in range(x0.shape[1]):
            gx = gradxX[i, j]
            gy = gradyX[i, j]
            if i == 0 or i == x0.shape[0] - 1 or j == 0 or j == x0.shape[1] - 1:
                d = 1
            else:
                d = 1.0 / (1.0 + (gx * gx + gy * gy) / (lambda_ * lambda_))
            D[i, j] = d

    # Perform smoothing
    x1 = np.zeros_like(x0, dtype=np.float64)
    for i in range(1, x0.shape[0] - 1):
        for j in range(1, x0.shape[1] - 1):
            x10 = x0[i + 1, j]
            x01 = x0[i, j + 1]
            x20 = x0[i - 1, j]
            x02 = x0[i, j - 1]
            x00 = x0[i, j]

            d10 = D[i + 1, j]
            d01 = D[i, j + 1]
            d20 = D[i - 1, j]
            d02 = D[i, j - 1]
            d00 = D[i, j]

            x1[i, j] = x00 + (dt/4) * ((d10 + d00) * (x10 - x00) +
                                            (d01 + d00) * (x01 - x00) +
                                            (d20 + d00) * (x20 - x00) +
                                            (d02 + d00) * (x02 - x00))

    x0 = x1
    t += dt

  return x1

times = [1, 5, 10, 30, 100]
plt.figure(figsize=(15,10))
i=1
for t in times:
  img = nonlinearDiffusionFilter(noisy_image, t, 0.5)
  mse = np.mean((img - original_image)** 2)
  plt.subplot(2,3,i), plt.imshow(img, 'gray'), plt.title(f't = {t}, MSE = {mse}')
  i+=1
plt.subplot(2,3,6), plt.imshow(original_image, 'gray'), plt.title('Original image')
#plt.savefig('Diffrent_t_nldf.png')
plt.show()

lambda_vals = [0.5, 1, 2, 5, 10]
t = 10
plt.figure(figsize=(15,10))
i=1
for l in lambda_vals:
  img = nonlinearDiffusionFilter(noisy_image, t, lambda_=l)
  mse = np.mean((img - original_image)** 2)
  plt.subplot(2,3,i), plt.imshow(img, 'gray'), plt.title(f'λ = {l}, MSE = {mse}')
  i+=1
plt.subplot(2,3,6), plt.imshow(original_image, 'gray'), plt.title('Original image')
#plt.savefig('Diffrent_lambda_nldf.png')
plt.show()

#@title Extra
lambda_vals = [15, 20, 30, 50, 100]
t = 10
plt.figure(figsize=(15,10))
i=1
for l in lambda_vals:
  img = nonlinearDiffusionFilter(noisy_image, t, lambda_=l)
  mse = np.mean((img - original_image)** 2)
  plt.subplot(2,3,i), plt.imshow(img, 'gray'), plt.title(f'λ = {l}, MSE = {mse}')
  i+=1
plt.subplot(2,3,6), plt.imshow(original_image, 'gray'), plt.title('Original image')
#plt.savefig('Diffrent_lambda_nldf.png')
plt.show()

img = nonlinearDiffusionFilter(noisy_image, 10, lambda_=200)
plt.subplot
plt.imshow(img, 'gray')
plt.subplot(1,2,1), plt.imshow(img, 'gray'), plt.title('Smothed image λ = 200')
plt.subplot(1,2,2), plt.imshow(noisy_image, 'gray'), plt.title('Noisy image')
plt.show()

